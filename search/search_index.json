{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What's Polylith?","text":"<p> For a more visual quickstart, check out the short videos in the Videos &amp; tutorials section.</p> <p>Polylith is an architecture, with tooling support, originally built for Clojure. This project brings Polylith to Python.</p> <p>From the official Polylith Architecture docs:</p> <p>... Polylith is a software architecture that applies functional thinking at the system scale. It helps us build simple, maintainable, testable, and scalable backend systems. ...</p>"},{"location":"#what-problems-does-polylith-solve","title":"What problems does Polylith solve?","text":"<p>Polylith offers a solution to the Microservice vs Monolith tradeoffs. Microservices are great, but the standard kind of setup will probably introduce a new set of problems:</p> <ul> <li>Source code is spread out in several repositories.</li> <li>Duplicated code.</li> <li>Shared code need to be packaged as libraries - that means even more repositories.</li> <li>Microservices running different versions of tools and dependencies, potentially also different Python versions.</li> </ul> <p>Phew, that's a lot to maintain.</p> <p>Polylith addresses these types of issues, with simplistic solutions. In addition to that, Polylith is very much about the Developer Experience. It has support for REPL Driven Development - a workflow that makes coding both joyful and interactive.</p> <p>If you can improve just one thing in your software development, make it getting faster feedback. <sup>1</sup></p> <p>This type of Architecture will also let you postpone design decisions, like going for a Monolith or REST Microservices or Serverless functions. Your team can instead choose to focus on writing code and creating features. Make the decisions on how to deploy when you are ready for it.</p>"},{"location":"#well-suited-for-monorepos","title":"Well suited for Monorepos","text":"<p>Polylith is using a components-first architecture. You can think of it as building blocks, very much like LEGO bricks. All code lives in a Monorepo, available for reuse. Python code - the bricks - is separated from the infrastructure and the actual building of artifacts.</p> <p>This may sound complicated, but it isn't.</p> <p></p> <p>In short, Polylith is about:</p> <ul> <li>Viewing code as bricks that can be combined into features</li> <li>Making it easy to reuse code across apps, tools, serverless functions and services</li> <li>Keeping it simple</li> </ul>"},{"location":"#polylith-for-python","title":"Polylith for Python?","text":"<p>The Python tools for the Polylith Architecture is available as two options:</p> <ul> <li>A Poetry plugin. The plugin will add Polylith specific features to Poetry.</li> <li>A standalone CLI supporting Hatch, PDM, Rye, Pantsbuild and uv (and Poetry).</li> </ul>"},{"location":"#use-cases","title":"Use cases","text":""},{"location":"#microservices-and-apps","title":"Microservices and apps","text":"<p>The main use case is to support having one or more microservices (or apps) in a Monorepo, and share code between the services.</p>"},{"location":"#libraries","title":"Libraries","text":"<p>Polylith for Python has support for building libraries to be published at PyPI, even if it isn't the main use case. More details about how to package libraries in Packaging &amp; deploying.</p>"},{"location":"#structure-for-simplicity","title":"Structure for simplicity","text":"<p>Organizing, sorting and structuring things is difficult. Is there one folder structure to rule them all?</p> <p>There should be one-- and preferably only one --obvious way to do it. <sup>2</sup></p> <p>A good folder structure is one that makes it simple to reuse existing code and makes it easy to add new code. You shouldn't have to worry about these things. The Polylith Architecture offers a way to organize code that is simple, framework agnostic and scalable as projects grow.</p> <p>See The Polylith Workspace for how such a structure looks like.</p> <p></p>"},{"location":"#simple-is-better","title":"Simple is better","text":"<p>The main takeaway is to view code as small, reusable bricks, that ideally does one thing only. A brick is not the same thing as a library. So, what's the difference? Well, a library is a full blown feature. A brick can be a single function, or a parser. It can also be a thin wrapper around a third party tool.</p> <p>Simple is better than complex. <sup>2</sup></p> <p>In Python, a file is a module. One or more modules in a folder becomes a package. A good thing with this is that the code will be namespaced when importing it. Where does the idea of bricks fit in here? Well, a brick is a Python namespace package. Simple as that.</p> <p>Namespaces are one honking great idea -- let's do more of those! <sup>2</sup></p> <p>If you want to dig a bit deeper, you will find a lot more information about the Polylith Architecture in general from the official docs.</p> <ol> <li> <p>Dave Farley on twitter \u21a9</p> </li> <li> <p>From the Zen of Python\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"about/","title":"About this Open Source Project","text":"<p>Currently, there is one maintainer of the Python tools for the Polylith Architecture and several contributors.</p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>For code contributions (that are very much appreciated), have a look at the contributions guideline. You can also contribute with your ideas and feedback, by adding or commenting on a discussion at the discussions forum.</p>"},{"location":"about/#issues","title":"Issues","text":"<p>If you find bugs or things that doesn't work as expected, please add an Issue. This will be very helpful for the maintainers and contributors. By doing that, you are in fact contributing to improve the quality of the tool.</p>"},{"location":"about/#code-of-conduct","title":"Code of Conduct","text":"<p>You will find the code of conduct here.</p> <p>Having positive and constructive mindset when adding comments, feedback, Pull Requests or contributing to a discussion is a high motivator and source of inspiration for the maintainers of this project.</p>"},{"location":"about/#license","title":"License","text":"<p>The Python tools for the Polylith Architecture is using the MIT License.</p>"},{"location":"about/#whats-the-impact-if-the-development-of-this-project-would-go-stale","title":"What's the impact if the development of this project would go stale?","text":"<p>The development of this tool has been on a constant pace since the beginning, and new features and versions are deployed regularly. But The Future is unknown, what will happen if the maintainers won't be able to continue the development?</p> <p>The Python tools for the Polylith Architecture is primarily there for a great Developer Experience.  With the tool, you can visualize the Monorepo, create bricks and projects in a simple way and you can easily validate the dependencies.</p> <p>The tooling is not incorporated into your source code, and you won't be \"vendor locked-in\" as with a Framework. Polylith is not a Framework. Migrating away from Polylith is really simple too. You do that with one single command!</p> <p>Additionally, this is an Open Source project and can (of course) be forked with continous development.</p>"},{"location":"commands/","title":"Commands","text":""},{"location":"commands/#create-a-workspace","title":"Create a workspace","text":"<p>This will create a Polylith workspace, with a basic Polylith folder structure.</p>"},{"location":"commands/#poetry","title":"Poetry","text":"<pre><code>poetry poly create workspace --name my_example_namespace --theme loose\n</code></pre>"},{"location":"commands/#hatch","title":"Hatch","text":"<pre><code>hatch run poly create workspace --name my_example_namespace --theme loose\n</code></pre>"},{"location":"commands/#pdm","title":"PDM","text":"<pre><code>pdm run poly create workspace --name my_example_namespace --theme loose\n</code></pre>"},{"location":"commands/#rye","title":"Rye","text":"<pre><code>rye run poly create workspace --name my_example_namespace --theme loose\n</code></pre>"},{"location":"commands/#uv","title":"uv","text":"<pre><code>uv run poly create workspace --name my_example_namespace --theme loose\n</code></pre>"},{"location":"commands/#options","title":"Options","text":"<p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace (see below).</p>"},{"location":"commands/#themes","title":"Themes","text":"<p>Themes are an exclusive Python Polylith feature, and defines what kind of workspace structure to use.</p>"},{"location":"commands/#loose-recommended","title":"loose (recommended)","text":"<p>A theme to use for a more familiar structure for Python: components/namespace/package and will put a test folder at the root of the repository.</p>"},{"location":"commands/#tdd","title":"tdd","text":"<p>The default and will set the structure according to the original Polylith Clojure implementation, such as: components/package/src/namespace/package with a corresponding test folder.</p>"},{"location":"commands/#whats-the-deal-with-the-keep-files","title":"What's the deal with the .keep files?","text":"<p>When creating a new workspace, the Polylith tool will add <code>.keep</code> files in the newly created folders. These are added for any initial commits of the folder structure, and can safely be removed when adding source files.</p>"},{"location":"commands/#create-a-component","title":"Create a component","text":"<p>This command will create a component - i.e. a Python package in a namespaced folder.</p>"},{"location":"commands/#poetry_1","title":"Poetry","text":"<pre><code>poetry poly create component --name my_example_component\n</code></pre>"},{"location":"commands/#hatch_1","title":"Hatch","text":"<pre><code>hatch run poly create component --name my_example_component\n</code></pre>"},{"location":"commands/#pdm_1","title":"PDM","text":"<pre><code>pdm run poly create component --name my_example_component\n</code></pre>"},{"location":"commands/#rye_1","title":"Rye","text":"<pre><code>rye run poly create component --name my_example_component\n</code></pre>"},{"location":"commands/#uv_1","title":"uv","text":"<pre><code>uv run poly create component --name my_example_component\n</code></pre>"},{"location":"commands/#options_1","title":"Options","text":"<p><code>--name</code> (required) the name of the component.</p> <p><code>--description</code> adding a docstring to the base. It will also be added in the README, when enabled in the configuration. See configuration.</p>"},{"location":"commands/#create-a-base","title":"Create a base","text":"<p>This command will create a base - i.e. a Python package in a namespaced folder.</p>"},{"location":"commands/#poetry_2","title":"Poetry","text":"<pre><code>poetry poly create base --name my_example_base\n</code></pre>"},{"location":"commands/#hatch_2","title":"Hatch","text":"<pre><code>hatch run poly create base --name my_example_base\n</code></pre>"},{"location":"commands/#pdm_2","title":"PDM","text":"<pre><code>pdm run poly create base --name my_example_base\n</code></pre>"},{"location":"commands/#rye_2","title":"Rye","text":"<pre><code>rye run poly create base --name my_example_base\n</code></pre>"},{"location":"commands/#uv_2","title":"uv","text":"<pre><code>uv run poly create base --name my_example_base\n</code></pre>"},{"location":"commands/#options_2","title":"Options","text":"<p><code>--name</code> (required) the name of the base.</p> <p><code>--description</code> adding a docstring to the base. It will also be added in the README, when enabled in the configuration. See configuration.</p>"},{"location":"commands/#create-a-project","title":"Create a project","text":"<p>This command will create a project - i.e. a pyproject.toml in a project folder.</p>"},{"location":"commands/#poetry_3","title":"Poetry","text":"<pre><code>poetry poly create project --name my_example_project\n</code></pre>"},{"location":"commands/#hatch_3","title":"Hatch","text":"<pre><code>hatch run poly create project --name my_example_project\n</code></pre>"},{"location":"commands/#pdm_3","title":"PDM","text":"<pre><code>pdm run poly create project --name my_example_project\n</code></pre>"},{"location":"commands/#rye_3","title":"Rye","text":"<pre><code>rye run poly create project --name my_example_project\n</code></pre>"},{"location":"commands/#uv_3","title":"uv","text":"<pre><code>uv run poly create project --name my_example_project\n</code></pre>"},{"location":"commands/#options_3","title":"Options","text":"<p><code>--name</code> (required) the name of the project.</p> <p><code>--description</code> adding a pyproject.toml description.</p>"},{"location":"commands/#info","title":"Info","text":"<p>Show info about the workspace:</p>"},{"location":"commands/#poetry_4","title":"Poetry","text":"<pre><code>poetry poly info\n</code></pre>"},{"location":"commands/#hatch_4","title":"Hatch","text":"<pre><code>hatch run poly info\n</code></pre>"},{"location":"commands/#pdm_4","title":"PDM","text":"<pre><code>pdm run poly info\n</code></pre>"},{"location":"commands/#rye_4","title":"Rye","text":"<pre><code>rye run poly info\n</code></pre>"},{"location":"commands/#uv_4","title":"uv","text":"<pre><code>uv run poly info\n</code></pre>"},{"location":"commands/#options_4","title":"Options","text":"<p><code>--short</code> Display a view that is better adjusted to Workspaces with many projects.</p>"},{"location":"commands/#diff","title":"Diff","text":"<p>Shows what has changed since the most recent stable point in time:</p>"},{"location":"commands/#poetry_5","title":"Poetry","text":"<pre><code>poetry poly diff\n</code></pre>"},{"location":"commands/#hatch_5","title":"Hatch","text":"<pre><code>hatch run poly diff\n</code></pre>"},{"location":"commands/#pdm_5","title":"PDM","text":"<pre><code>pdm run poly diff\n</code></pre>"},{"location":"commands/#rye_5","title":"Rye","text":"<pre><code>rye run poly diff\n</code></pre>"},{"location":"commands/#uv_5","title":"uv","text":"<pre><code>uv run poly diff\n</code></pre> <p>The <code>diff</code> command will compare the current state of the repository, compared to a <code>git tag</code>. The tool will look for the latest tag according to a certain pattern, such as <code>stable-*</code>. The pattern can be configured in the Workspace configuration.</p> <p>The <code>diff</code> command is useful in a CI environment, to determine if a project should be deployed or not. It is also useful when running tests for changed bricks only.</p> <p>Example:</p>"},{"location":"commands/#poetry_6","title":"Poetry","text":"<pre><code>poetry poly diff --since release\n</code></pre>"},{"location":"commands/#hatch_6","title":"Hatch","text":"<pre><code>hatch run poly diff --since release\n</code></pre>"},{"location":"commands/#pdm_6","title":"PDM","text":"<pre><code>pdm run poly diff --since release\n</code></pre>"},{"location":"commands/#rye_6","title":"Rye","text":"<pre><code>rye run poly diff --since release\n</code></pre>"},{"location":"commands/#rye_7","title":"Rye","text":"<pre><code>uv run poly diff --since release\n</code></pre>"},{"location":"commands/#options_5","title":"Options","text":"<p><code>--short</code> Useful for determining what projects has been affected by the changes in CI.</p> <p><code>--bricks</code> Useful for displaying changed bricks only. It will print a comma-separated list of bricks when using it with the <code>--short</code> option.</p> <p><code>--since</code> Useful for displaying changes since a <code>stable</code> or <code>release</code> tag. The tag patterns are defined in the Workspace configuration. This option also support using a specific commit hash.</p> <p><code>--deps</code> Useful for displaying the bricks that are used by the changed bricks. Use it with the <code>--bricks</code> option.</p>"},{"location":"commands/#libs","title":"Libs","text":"<p>Show info about the third-party libraries used in the workspace:</p>"},{"location":"commands/#poetry_7","title":"Poetry","text":"<pre><code>poetry poly libs\n</code></pre> <p>This feature relies on installed project dependencies, and expects a <code>poetry.lock</code> of a project to be present. If missing, there is a Poetry command available: <pre><code>poetry lock --directory path/to-project\n</code></pre></p>"},{"location":"commands/#hatch_7","title":"Hatch","text":"<pre><code>hatch run poly libs\n</code></pre>"},{"location":"commands/#pdm_7","title":"PDM","text":"<pre><code>pdm run poly libs\n</code></pre>"},{"location":"commands/#rye_8","title":"Rye","text":"<pre><code>rye run poly libs\n</code></pre>"},{"location":"commands/#uv_6","title":"uv","text":"<pre><code>uv run poly libs\n</code></pre>"},{"location":"commands/#options_6","title":"Options","text":"<p><code>--directory</code> Show info about libraries used in a specific project.</p> <p><code>--strict</code> A more narrow way of comparing third-party libraries and the actual imports. This is useful to rule out possible false positives.</p> <p><code>--alias</code> Useful when an import differ from the library name.</p> <p>Example: the library \"opencv-python\" and the actual import \"cv2\". The poly libs command will likely report the \"cv2\" as a missing dependency.</p> <p>Using <code>--alias opencv-python=cv2</code> will make the command treat the alias as a third-party import.</p>"},{"location":"commands/#check","title":"Check","text":"<p>Validates the Polylith workspace, checking for any missing dependencies (bricks and third-party libraries):</p>"},{"location":"commands/#poetry_8","title":"Poetry","text":"<pre><code>poetry poly check\n</code></pre> <p>This feature is built on top of the <code>poly libs</code> command, and for expects a <code>poetry.lock</code> of a <code>Poetry</code> project to be present.</p>"},{"location":"commands/#hatch_8","title":"Hatch","text":"<pre><code>hatch run poly check\n</code></pre>"},{"location":"commands/#pdm_8","title":"PDM","text":"<pre><code>pdm run poly check\n</code></pre>"},{"location":"commands/#rye_9","title":"Rye","text":"<pre><code>rye run poly check\n</code></pre>"},{"location":"commands/#uv_7","title":"uv","text":"<pre><code>uv run poly check\n</code></pre>"},{"location":"commands/#options_7","title":"Options","text":"<p><code>--directory</code> Show info about libraries used in a specific project.</p> <p><code>--strict</code> A more narrow way of comparing third-party libraries, versions and the actual imports. This is useful to rule out possible false positives, and to ensure using the same version strings for the libraries across the workspace.</p> <p><code>--alias</code> Useful when an import differ from the library name.</p> <p>Example: the library \"opencv-python\" and the actual import \"cv2\". The poly check command will likely report the \"cv2\" as a missing dependency.</p> <p>Using <code>--alias opencv-python=cv2</code> will make the command treat the alias as a third-party import.</p>"},{"location":"commands/#sync","title":"Sync","text":"<p>Keep projects in sync with the actual usage of bricks in source code.</p>"},{"location":"commands/#poetry_9","title":"Poetry","text":"<pre><code>poetry poly sync\n</code></pre>"},{"location":"commands/#hatch_9","title":"Hatch","text":"<pre><code>hatch run poly sync\n</code></pre>"},{"location":"commands/#pdm_9","title":"PDM","text":"<pre><code>pdm run poly sync\n</code></pre>"},{"location":"commands/#rye_10","title":"Rye","text":"<pre><code>rye run poly sync\n</code></pre>"},{"location":"commands/#uv_8","title":"uv","text":"<pre><code>uv run poly sync\n</code></pre> <p>This feature is useful for keeping projects in sync. The command will analyze code and add any missing bricks to the projects, including the development project.</p> <ul> <li>projects: will add missing bricks to the project specific pyproject.toml, when imported by any of the already added bricks.</li> <li>development: will add all missing bricks to the development pyproject.toml.</li> </ul>"},{"location":"commands/#options_8","title":"Options","text":"<p><code>--directory</code> Synchronize a specific project.</p>"},{"location":"commands/#deps","title":"Deps","text":"<p>Show dependencies between bricks.</p>"},{"location":"commands/#poetry_10","title":"Poetry","text":"<pre><code>poetry poly deps\n</code></pre>"},{"location":"commands/#hatch_10","title":"Hatch","text":"<pre><code>hatch run poly deps\n</code></pre>"},{"location":"commands/#pdm_10","title":"PDM","text":"<pre><code>pdm run poly deps\n</code></pre>"},{"location":"commands/#rye_11","title":"Rye","text":"<pre><code>rye run poly deps\n</code></pre>"},{"location":"commands/#uv_9","title":"uv","text":"<pre><code>uv run poly deps\n</code></pre>"},{"location":"commands/#options_9","title":"Options","text":"<p><code>--directory</code> Show brick depencencies for a specific project.</p> <p><code>--brick</code> A detailed view for a single brick and the dependent bricks: used by, and uses.</p>"},{"location":"commands/#testing","title":"Testing","text":"<p>Example, how to run pytest for changed bricks only.</p>"},{"location":"commands/#poetry_11","title":"Poetry","text":"<pre><code># store the comma-separated list of bricks in a bash variable\nchanges=\"$(poetry poly diff --bricks --short)\"\n\n# transform it into a pytest query,\n# i.e. from \"hello,world,something\" to \"hello or world or something\"\nquery=\"${changes//,/ or }\"\n</code></pre> <p>Run the test, filtered by keyword expression</p> <pre><code>poetry run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre> <p>or run the test, filtered by pytest markers</p> <pre><code>poetry run pytest -m &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"commands/#hatch_11","title":"Hatch","text":"<pre><code># store the comma-separated list of bricks in a bash variable\nchanges=\"$(hatch run poly diff --bricks --short)\"\n\n# transform it into a pytest query,\n# i.e. from \"hello,world,something\" to \"hello or world or something\"\nquery=\"${changes//,/ or }\"\n</code></pre> <p>Run the test, filtered by keyword expression</p> <pre><code>hatch run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre> <p>or run the test, filtered by pytest markers</p> <pre><code>hatch run pytest -m &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"commands/#pdm_11","title":"PDM","text":"<pre><code># store the comma-separated list of bricks in a bash variable\nchanges=\"$(pdm run poly diff --bricks --short)\"\n\n# transform it into a pytest query,\n# i.e. from \"hello,world,something\" to \"hello or world or something\"\nquery=\"${changes//,/ or }\"\n</code></pre> <p>Run the test, filtered by keyword expression</p> <pre><code>pdm run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre> <p>or run the test, filtered by pytest markers</p> <pre><code>pdm run pytest -m &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"commands/#rye_12","title":"Rye","text":"<pre><code># store the comma-separated list of bricks in a bash variable\nchanges=\"$(rye run poly diff --bricks --short)\"\n\n# transform it into a pytest query,\n# i.e. from \"hello,world,something\" to \"hello or world or something\"\nquery=\"${changes//,/ or }\"\n</code></pre> <p>Run the test, filtered by keyword expression</p> <pre><code>rye run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre> <p>or run the test, filtered by pytest markers</p> <pre><code>rye run pytest -m &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"commands/#uv_10","title":"uv","text":"<pre><code># store the comma-separated list of bricks in a bash variable\nchanges=\"$(uv run poly diff --bricks --short)\"\n\n# transform it into a pytest query,\n# i.e. from \"hello,world,something\" to \"hello or world or something\"\nquery=\"${changes//,/ or }\"\n</code></pre> <p>Run the test, filtered by keyword expression</p> <pre><code>uv run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre> <p>or run the test, filtered by pytest markers</p> <pre><code>uv run pytest -m &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The Polylith Workspace is configured using a workspace.toml file at the root of the workspace.</p> <p>A default configuration is created when running the <code>poly create workspace</code> command (see the commands section).</p> <p> As an alternative, you can put the configuration in the top <code>pyproject.toml</code>.</p> <p>Example of a workspace configuration:</p> <pre><code>[tool.polylith]\nnamespace = \"my_example_namespace\"\n\n[tool.polylith.structure]\ntheme = \"loose\"\n\n[tool.polylith.tag.patterns]\nstable = \"stable-*\"\nrelease = \"v[0-9]*\"\n\n[tool.polylith.resources]\nbrick_docs_enabled = false\n\n[tool.polylith.test]\nenabled = true\n</code></pre>"},{"location":"configuration/#tags","title":"Tags","text":"<p>Check for changes since a tag. Configure the tag pattern.</p> <p>The preferred way of defining tag patterns is: <pre><code>[tool.polylith.tag.patterns]\nstable = \"stable-*\"\nrelease = \"v[0-9]*\"\n</code></pre></p> <p>By default, Polylith uses the <code>-committerdate</code> when fetching tags with the underlying <code>git</code> command. The sorting might be incorrect when using annotated tags. To solve this, you can configure the sorting.</p> <p>Example, setting a different sorting option than the default: <pre><code>[tool.polylith.tag]\nsorting = [\"-creatordate\"]\n</code></pre></p>"},{"location":"configuration/#components-and-bases-documentation","title":"Components and bases documentation","text":"<p>When <code>brick_docs_enabeld = true</code>, a README is added when creating a component or a base.</p>"},{"location":"configuration/#testing","title":"Testing","text":"<p>The create component and brick commands will also create corresponding unit tests when <code>enabled = true</code> in the test section of the workspace configuration.</p>"},{"location":"dependencies/","title":"Dependencies","text":"<p>Projects are located in the projects folder of a Polylith workspace. Each project has its own <code>pyproject.toml</code>, where the project-specific dependencies are defined.</p>"},{"location":"dependencies/#bricks-your-python-code","title":"Bricks (your Python code)","text":"<p>Bricks are added to the <code>packages</code> section of <code>[tool.poetry]</code> or the <code>[tool.hatch.build.force-include]</code>, described in Projects &amp; pyproject.toml.</p> <p>To keep a project up-to-date with needed bricks, there is a <code>poly sync</code> command available. Usage is described in commands. The command is there for convenience, you can also add the bricks manually.</p>"},{"location":"dependencies/#libraries-third-party-dependencies","title":"Libraries (third-party dependencies)","text":"<p>The recommended workflow for Polylith is to use <code>poetry add</code>, or manually adding, to install the needed libraries to the Development <code>pyproject.toml</code>. The Development <code>pyproject.toml</code> is located at the Workspace root. The Development environment should have all dependencies added: all bricks and all the third-party libraries. The dev-dependencies (such as Mypy, Black, Flake8, Ruff etc.) are also added to the Development <code>pyproject.toml</code>.</p> <p>A Project should only include the dependencies that are needed for it to run in a production environment.</p> <p>Libraries are added separately into the project-specific <code>pyproject.toml</code> (pick the depencencies based on what's already in Development).  The Python tools for the Polylith Architecture has a keep-things-simple approach to dependencies: just copy the needed dependencies from the development project, or use <code>poetry add</code> into a project.</p> <p>Use the <code>poly libs</code> and/or <code>poly check</code> command to verify all that all dependencies have been added.</p> <p>Both commands support the <code>--directory</code> option (coming from Poetry). This means that you can run the commands from the workspace root, but for a specific project:</p>"},{"location":"dependencies/#poetry","title":"Poetry","text":"<pre><code>poetry poly check --directory projects/my-project\n</code></pre>"},{"location":"dependencies/#hatch","title":"Hatch","text":"<pre><code>hatch run poly check --directory projects/my-project\n</code></pre>"},{"location":"dependencies/#pdm","title":"PDM","text":"<pre><code>pdm run poly check --directory projects/my-project\n</code></pre>"},{"location":"dependencies/#rye","title":"Rye","text":"<pre><code>rye run poly check --directory projects/my-project\n</code></pre>"},{"location":"dependencies/#uv","title":"uv","text":"<pre><code>uv run poly check --directory projects/my-project\n</code></pre>"},{"location":"deployment/","title":"Packaging &amp; deploying","text":""},{"location":"deployment/#poetry","title":"Poetry","text":"<p>Packaging and deploying Polylith projects is done by using the Poetry Multiproject plugin command (see installation).</p> <p>The <code>poetry build-project</code> command will make it possible to use relative package includes as how components and bases are added to Python Polylith projects.  Relative includes are currently not possible by default in Poetry, that is where the Multiproject plugin comes in.</p>"},{"location":"deployment/#hatch-pdm-rye-and-uv","title":"Hatch, PDM, Rye and uv","text":"<p>Hatch, PDM, Rye and uv support relative includes via the <code>[tool.poetry.bricks]</code> configuration. Nothing extra needed other than the build hooks.</p>"},{"location":"deployment/#building-source-distributions-sdist","title":"Building source distributions (sdist)?","text":"<p>If you will distribute an <code>sdist</code> as the primary way to install your package, you will need to add the path in the project-specific <code>pyroject.toml</code>.</p> <p>If you only provide <code>wheel</code> distributions, this is optional.</p>"},{"location":"deployment/#hatch-rye-and-uv","title":"Hatch, Rye and uv","text":"<pre><code>[tool.hatch.build.targets.wheel]\npackages = [\"&lt;your top namespace here&gt;\"]\n</code></pre>"},{"location":"deployment/#pdm","title":"PDM","text":"<pre><code>[tool.pdm.build]\nincludes = [\"&lt;your top namespace here&gt;/\"]\n</code></pre>"},{"location":"deployment/#packaging","title":"Packaging","text":"<p>To collect the components and bases that are needed for a specific project, the tool introduces a build step.  The tool will build a wheel and an sdist from the source code of a project.</p> <p>This is the preferred way for Polylith projects.</p>"},{"location":"deployment/#packaging-a-service-or-app","title":"Packaging a service or app","text":""},{"location":"deployment/#poetry_1","title":"Poetry","text":"<pre><code>poetry build-project --directory path/to/project\n</code></pre>"},{"location":"deployment/#hatch","title":"Hatch","text":"<pre><code>cd path/to_project\n\nhatch build\n</code></pre>"},{"location":"deployment/#pdm_1","title":"PDM","text":"<pre><code>cd path/to_project\n\npdm build\n</code></pre>"},{"location":"deployment/#rye","title":"Rye","text":"<pre><code>cd path/to_project\n\n# run the build command for each output\nrye build --wheel\nrye build --sdist\n</code></pre>"},{"location":"deployment/#uv","title":"uv","text":"<pre><code>cd path/to_project\n\nuvx --from build pyproject-build --installer uv\n</code></pre> <p>This command will create a project specific dist folder containing a wheel and an sdist. You can use the available build options with this command too.</p>"},{"location":"deployment/#deploying","title":"Deploying","text":"<p>You can use the built artifacts to install your service in your preffered way, just by running</p> <pre><code>pip install the-built-artifact.whl\n</code></pre>"},{"location":"deployment/#packaging-a-library","title":"Packaging a Library","text":"<p>The Python tools for the Polylith Architecture has support for building libraries to be published at PyPI, even if it isn't the main use case.</p> <p>Important note: by default, the code in one library will share the same top namespace with other libraries that are built from the same Polylith Monorepo. To solve this, there's a feature available that will organize code according to a custom top namespace and re-write the imports.</p>"},{"location":"deployment/#poetry_2","title":"Poetry","text":"<p>You can choose a custom namespace to be used in the build process, by using the <code>--with-top-namespace</code> flag. This is available for Python 3.9 and above.</p> <p>The <code>build-project</code> command, with a custom top namespace:</p> <pre><code>poetry build-project --with-top-namespace my_custom_namespace\n</code></pre>"},{"location":"deployment/#hatch-pdm-rye-and-uv_1","title":"Hatch, PDM, Rye and uv","text":"<p>A custom top namespace is defined in the project-specific <code>pyproject.toml</code>:</p> <pre><code>[tool.polylith.build]\ntop-namespace = \"my_custom_namespace\"\n</code></pre>"},{"location":"deployment/#result","title":"Result","text":"<p>By using the Poetry build-project flag or the Hatch Build Hook, the built artifact will look something like this: <pre><code>my_custom_namespace/\n   /the_namespace\n       /the_brick\n           __init__.py\n           my_module.py\n</code></pre></p> <p>And the Python modules will have the custom top namespace as a prefix to imports: <pre><code>from my_custom_namespace.the_namespace.the_brick import my_function\n</code></pre></p>"},{"location":"deployment/#how-is-this-done","title":"How is this done?","text":"<p>The command uses AST (Abstract Syntax Tree) parsing to modify source code. The Python built-in <code>ast</code> module is used to parse and un-parse Python code.</p>"},{"location":"deployment/#script-entrypoints","title":"Script Entrypoints","text":"<p>If you have a script entrypoint, remember to manually add the custom namespace in your <code>pyproject.toml</code>.</p> <p>Example (Poetry):</p> <pre><code># manually adding the my_custom_namespace at the beginning\n\n[tool.poetry.scripts]\nmy_script = \"my_custom_namespace.the_namespace.the_brick.my_module:main\"\n</code></pre>"},{"location":"examples/","title":"Examples &amp; Production Systems","text":""},{"location":"examples/#example-code-repositories","title":"Example code repositories","text":"<p>Here are some examples of how to setup Python with the Polylith Architecture.</p> <ul> <li>Python Polylith Example Monorepo<ul> <li>for Poetry</li> <li>for Hatch</li> <li>for PDM</li> <li>for Rye</li> <li>for Pants</li> <li>for uv</li> </ul> </li> <li>Python Polylith Microservices Example by Matt Gosden</li> <li>Aws CDK App with Polylith by Yoel Ben\u00edtez Fonseca</li> </ul> <p>You will find examples of sharing code between different kind of projects, developer tooling configuration such as <code>mypy</code> and the <code>venv</code>, and development setup for REPL Driven Development or Jupyter notebooks.</p>"},{"location":"examples/#production-systems","title":"Production Systems","text":""},{"location":"examples/#runestone-academy","title":"Runestone Academy","text":"<p>Runestone Academy is an open-source project and our mission is to equip the nation's STEM teachers with open-source content, tools and strategies they need to create engaging, accessible, and effective learning experiences for their students. </p> <p>Runestone Academy Monorepo</p> <p></p>"},{"location":"examples/#britned","title":"BritNed","text":"<p>BritNed - Electricity interconnector, connecting the United Kingdom with the European mainland through the Netherlands. Polylith-Python is the foundation under our (internal) data warehouse which extracts/transforms data from multiple systems in our operation.</p>"},{"location":"examples/#other","title":"Other","text":"<p>In addition to the examples and Production Systems, there is also the actual Python tools for the Polylith Architecture repo, that itself is a Polylith Workspace.</p>"},{"location":"examples/#your-project-here","title":"Your project here?","text":"<p>Do you have a Polylith repository that you or your company would like to share here? You are very much welcome to make a Pull Request, or create a Github issue to the python-polylith-docs repo.</p>"},{"location":"ide/","title":"Configuring your Python IDE","text":""},{"location":"ide/#mypy","title":"MyPy","text":"<p>Add this configuration if you use MyPy for static analysis. With this configuration, namespace packages will be enabled and top-level packages will be based in the <code>mypy_path</code> option.</p> <pre><code>[mypy]\nmypy_path = components, bases\nnamespace_packages = True\nexplicit_package_bases = True\n</code></pre>"},{"location":"ide/#pyright","title":"Pyright","text":"<p>Pyright users can add this setting to make the tool aware of the <code>components</code> and <code>bases</code> folders.</p> <p><code>.vscode/settings.json</code></p> <pre><code>{\n  \"python.analysis.extraPaths\": [\n    \"bases\",\n    \"components\"\n  ]\n}\n</code></pre> <p><code>pyproject.toml</code></p> <pre><code>[tool.pyright]\nextraPaths = [\"bases\", \"components\"]\n</code></pre>"},{"location":"ide/#venv","title":".venv","text":"<p>It is recommended to create the virtual environment locally, for a great code editor experience. By default, both <code>Poetry</code> and <code>Hatch</code> will create a <code>venv</code> outside of the repo. You can override that behaviour by adding a configuration.</p>"},{"location":"ide/#poetry","title":"Poetry","text":"<p>Add this in a <code>poetry.toml</code> file:</p> <pre><code>[virtualenvs]\npath = \".venv\"\nin-project = true\n</code></pre>"},{"location":"ide/#hatch","title":"Hatch","text":"<pre><code>[tool.hatch.envs.default]\ntype = \"virtual\"\npath = \".venv\"\n</code></pre>"},{"location":"ide/#pycharm","title":"PyCharm","text":"<p>Make sure that you have a local virtual environment configuration (see above).</p> <p>Run <code>poetry install</code> or <code>hatch env create</code> in a shell.</p> <p>This will install the dependencies, and make the environment aware of the <code>bases</code> and <code>components</code> folders. PyCharm will ask about what interpreter to use when opening a Python file. Make sure to choose the local one in the <code>.venv</code> folder.</p> <p>Everything should now be set up correctly for PyCharm!</p> <p></p>"},{"location":"ide/#breaking-nuance-references-corrections","title":"Breaking nuance: references corrections","text":"<p>In PyCharm, if you try to move a file from, say, one of the bases to one of the components, the IDE will show you a confirmation dialog with <code>Search for references</code> checkbox, which may or may not be checked by default.</p> <p>It's better to uncheck it.</p> <p>This is because, if the name of your file is generic (i.e. files with the same name can be encountered in other places in this repo), PyCharm would look for reference to it and get confused, and may decide that there is an error that should be fixed. It would then  create a <code>__init__.py</code> file in the core of either <code>components/{namespace}</code> or <code>bases/{namespace}</code> directory, and this would lead to incorrectly interpreting the project structure. </p> <p>In practice, this means that either components won't work, or bases, or both. This can be spotted by looking at the component-level (or base-level) <code>__init__.py</code> files, where the imports would be marked as faulty.</p> <p>This issue can be fixed by one of the following:</p> <ul> <li>remove the automatically created <code>__init__.py</code>;</li> <li>re-create your virtual environment;</li> <li>revert your git repository to the commit before moving the file.</li> </ul> <p>These methods are listed in the order they should be attempted - if one works, no need to do the others. The first one should work for most cases.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#poetry","title":"Poetry","text":""},{"location":"installation/#add-poetry-plugins","title":"Add Poetry plugins","text":"<p>With the <code>Poetry</code> version 1.2 or later installed, you can add plugins. First, add the Multiproject plugin, that will enable the very important Workspace support to Poetry. <pre><code>poetry self add poetry-multiproject-plugin\n</code></pre></p> <p>Add the Polylith plugin: <pre><code>poetry self add poetry-polylith-plugin\n</code></pre></p> <p>Done!</p>"},{"location":"installation/#hatch-pdm-rye-pantsbuild-and-uv","title":"Hatch, PDM, Rye, Pantsbuild and uv","text":"<p>No globally added tools needed. Add the project-specific dependencies (see the Setup and Projects &amp; pyproject.toml section), and the build hook plugins to add support for the Polylith structure and when packaging libraries.</p>"},{"location":"migrating/","title":"Migrating to Polylith","text":"<p>If you decide to give Polylith a try with existing code, the suggestion is to:</p> <ul> <li>create a new repo and workspace. See setup and commands.</li> <li>choose one of your existing services or apps to migrate into the newly created Polylith repo.</li> <li>create a base with the poly tool and put all of the existing Python code in there. Don't worry, we will fix this in next steps.</li> <li>create a new project with the poly tool - this will be the project infrastructure for the service or app that currently lives in the base you added in the prevous step.</li> </ul> <p>The entrypoint for your app would be something like:</p>"},{"location":"migrating/#poetry","title":"Poetry","text":"<pre><code>[tool.poetry]\npackages = [\n    {include = \"your_namespace/your_app\", from = \"../../bases\"}\n]\n\n[tool.poetry.dependencies]\n# insert the needed 3rd party libraries here\n</code></pre>"},{"location":"migrating/#hatch-pdm-rye-and-uv","title":"Hatch, PDM, Rye and uv","text":"<pre><code>[project]\ndependencies = [] # insert the needed 3rd party libraries here\n\n[tool.polylith.bricks]\n\"../../bases/your_namespace/your_app\" = \"your_namespace/your_app\"\n</code></pre> <p>You should now be able to run the service or app locally.</p>"},{"location":"migrating/#next-step-migrating-code-to-bricks","title":"Next step: migrating code to bricks","text":"<p>Now you are ready for the actual migration: identifying parts of the source code that could be grouped into what Polylith refers to as components. Moving them - one by one - out of the base and into new components. Add the components to the <code>pyproject.toml</code> according to the example in Projects &amp; pyproject.toml.</p>"},{"location":"migrating/#when-is-the-migration-finished","title":"When is the migration finished?","text":"<p>The base would ideally contain the entry point, and import all the needed components. You can test out the service or app, run the <code>info</code>, <code>libs</code> and <code>check</code> commands to verify all things are in place. See commands.</p> <p>Continue with your next existing service or app! By now, you should already be able to share components between your services.</p>"},{"location":"migrating/#migrating-away-from-polylith","title":"Migrating away from Polylith?","text":"<p>This step is simple.</p>"},{"location":"migrating/#poetry_1","title":"Poetry","text":"<pre><code>poetry build-project --directory path/to/project\n</code></pre>"},{"location":"migrating/#hatch","title":"Hatch","text":"<pre><code>cd path/to/project\n\nhatch build\n</code></pre>"},{"location":"migrating/#pdm","title":"PDM","text":"<pre><code>cd path/to/project\n\npdm build\n</code></pre>"},{"location":"migrating/#rye","title":"Rye","text":"<pre><code>cd path/to_project\n\nrye build --sdist\n</code></pre>"},{"location":"migrating/#uv","title":"uv","text":"<pre><code>cd path/to_project\n\nuvx --from build pyproject-build --installer uv\n</code></pre> <p>The output is a <code>wheel</code> and, more importantly, an <code>sdist</code> (a source distribution). It is essentially a zip file containing all source code used in the project.</p> <p>That's all!</p>"},{"location":"projects/","title":"Projects &amp; pyproject.toml","text":"<p>Projects are located in the projects folder of a Polylith workspace. Each project has its own <code>pyproject.toml</code>, where dependencies and project-specific things are defined. Just as in a mainstream Poetry or Hatch project.</p> <p>What differs is how the Polylith components and bases (aka bricks) are referenced. </p>"},{"location":"projects/#poetry","title":"Poetry","text":"<p>Bricks are added in the tool.poetry section as packages:</p> <pre><code>[tool.poetry]\nname = \"my_example_project\"\npackages = [\n         {include = \"my_namespace/my_base\", from = \"../../bases\"},\n         {include = \"my_namespace/my_component\", from = \"../../components\"},\n         {include = \"my_namespace/my_other_component\", from = \"../../components\"}\n]\n</code></pre> <p>Note the from attribute, where the base and components are referenced with relative paths. The <code>bases</code> and <code>components</code> folders are located at the workspace root. The project-specific <code>pyproject.toml</code> file is located in a subfolder of the <code>projects</code> folder.</p>"},{"location":"projects/#hatch","title":"Hatch","text":""},{"location":"projects/#the-pyprojecttoml-in-the-workspace-ie-the-one-in-the-root-folder","title":"The pyproject.toml in the Workspace (i.e. the one in the root folder)","text":"<p>Add the <code>polylith-cli</code> to the workspace <code>pyproject.toml</code> configuration. <pre><code>[tool.hatch.envs.default]\ndependencies = [\"polylith-cli\"]\n</code></pre> Add configuration for a local virtual environment: <pre><code>[tool.hatch.envs.default]\ntype = \"virtual\"\npath = \".venv\"\npython = \"3.12\"  # your preferred version here\n</code></pre></p> <p>Make Hatch aware of the Polylith structure:</p> <pre><code>[tool.hatch.build]\ndev-mode-dirs = [\"components\", \"bases\", \"development\", \".\"]\n</code></pre>"},{"location":"projects/#the-project-specific-pyprojecttoml-files","title":"The project-specific pyproject.toml file(s)","text":"<pre><code>[build-system]\nrequires = [\"hatchling\", \"hatch-polylith-bricks\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.hooks.polylith-bricks]\n# this section is needed to enable the hook in the build process, even if empty.\n</code></pre> <p>Polylith bricks are added in the <code>[tool.polylith.bricks]</code> section:</p> <pre><code>[tool.polylith.bricks]\n\"../../bases/my_namespace/my_base\" = \"my_namespace/my_base\"\n\"../../components/my_namespace/my_component\" = \"my_namespace/my_component\"\n\"../../components/my_namespace/my_other_component\" = \"my_namespace/my_other_component\"\n</code></pre>"},{"location":"projects/#pdm","title":"PDM","text":""},{"location":"projects/#the-pyprojecttoml-in-the-workspace-ie-the-one-in-the-root-folder_1","title":"The pyproject.toml in the Workspace (i.e. the one in the root folder)","text":"<p>Add the <code>workspace</code> PDM build hook: <pre><code>[build-system]\nrequires = [\"pdm-backend\", \"pdm-polylith-workspace\"]\nbuild-backend = \"pdm.backend\"\n</code></pre></p>"},{"location":"projects/#the-project-specific-pyprojecttoml-files_1","title":"The project-specific pyproject.toml file(s)","text":"<p>Add the <code>project</code> PDM build hook: <pre><code>[build-system]\nrequires = [\"pdm-backend\", \"pdm-polylith-bricks\"]\nbuild-backend = \"pdm.backend\"\n</code></pre></p> <p>Polylith bricks are added in the <code>[tool.polylith.bricks]</code> section:</p> <pre><code>[tool.polylith.bricks]\n\"../../bases/my_namespace/my_base\" = \"my_namespace/my_base\"\n\"../../components/my_namespace/my_component\" = \"my_namespace/my_component\"\n\"../../components/my_namespace/my_other_component\" = \"my_namespace/my_other_component\"\n</code></pre>"},{"location":"projects/#rye","title":"Rye","text":""},{"location":"projects/#the-pyprojecttoml-in-the-workspace-ie-the-one-in-the-root-folder_2","title":"The pyproject.toml in the Workspace (i.e. the one in the root folder)","text":"<p>Add the <code>polylith-cli</code> to the workspace <code>pyproject.toml</code> configuration.</p> <p>Add it manually, or by running <code>rye add polylith-cli --dev</code>:</p> <pre><code>[tool.rye]\ndev-dependencies = [\"polylith-cli\"]\n</code></pre> <p>The default build backend for Rye is Hatch. Add the <code>hatch-polylith-bricks</code> build hook plugin to the <code>pyproject.toml</code> file.</p> <pre><code>[build-system]\nrequires = [\"hatchling\", \"hatch-polylith-bricks\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.hooks.polylith-bricks]\n# this section is needed to enable the hook in the build process, even if empty.\n</code></pre> <p>Make Rye (and Hatch) aware of the way Polylith organizes source code: <pre><code>[tool.hatch.build]\ndev-mode-dirs = [\"components\", \"bases\", \"development\", \".\"]\n</code></pre></p>"},{"location":"projects/#the-project-specific-pyprojecttoml-files_2","title":"The project-specific pyproject.toml file(s)","text":"<pre><code>[build-system]\nrequires = [\"hatchling\", \"hatch-polylith-bricks\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.hooks.polylith-bricks]\n# this section is needed to enable the hook in the build process, even if empty.\n</code></pre> <p>Polylith bricks are added in the <code>[tool.polylith.bricks]</code> section:</p> <pre><code>[tool.polylith.bricks]\n\"../../bases/my_namespace/my_base\" = \"my_namespace/my_base\"\n\"../../components/my_namespace/my_component\" = \"my_namespace/my_component\"\n\"../../components/my_namespace/my_other_component\" = \"my_namespace/my_other_component\"\n</code></pre> <p>The <code>bases</code> and <code>components</code> folders are located at the workspace root. The project-specific <code>pyproject.toml</code> file is located in a subfolder of the <code>projects</code> folder.</p>"},{"location":"projects/#uv","title":"uv","text":""},{"location":"projects/#the-pyprojecttoml-in-the-workspace-ie-the-one-in-the-root-folder_3","title":"The pyproject.toml in the Workspace (i.e. the one in the root folder)","text":"<p>Add the <code>polylith-cli</code> to the workspace <code>pyproject.toml</code> configuration.</p> <p>Add it manually, or by running <code>uv add polylith-cli --dev</code>:</p> <pre><code>[tool.uv]\ndev-dependencies = [\"polylith-cli\"]\n</code></pre> <p>The default build backend for uv is Hatch. Add the <code>hatch-polylith-bricks</code> build hook plugin to the <code>pyproject.toml</code> file.</p> <pre><code>[build-system]\nrequires = [\"hatchling\", \"hatch-polylith-bricks\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.hooks.polylith-bricks]\n# this section is needed to enable the hook in the build process, even if empty.\n</code></pre> <p>Make uv (and Hatch) aware of the way Polylith organizes source code: <pre><code>[tool.hatch.build]\ndev-mode-dirs = [\"components\", \"bases\", \"development\", \".\"]\n</code></pre></p>"},{"location":"projects/#the-project-specific-pyprojecttoml-files_3","title":"The project-specific pyproject.toml file(s)","text":"<pre><code>[build-system]\nrequires = [\"hatchling\", \"hatch-polylith-bricks\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.hooks.polylith-bricks]\n# this section is needed to enable the hook in the build process, even if empty.\n</code></pre> <p>Polylith bricks are added in the <code>[tool.polylith.bricks]</code> section:</p> <pre><code>[tool.polylith.bricks]\n\"../../bases/my_namespace/my_base\" = \"my_namespace/my_base\"\n\"../../components/my_namespace/my_component\" = \"my_namespace/my_component\"\n\"../../components/my_namespace/my_other_component\" = \"my_namespace/my_other_component\"\n</code></pre> <p>The <code>bases</code> and <code>components</code> folders are located at the workspace root. The project-specific <code>pyproject.toml</code> file is located in a subfolder of the <code>projects</code> folder.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#create-a-polylith-workspace","title":"Create a Polylith Workspace","text":"<p>Create a directory for your code, initialize it with git and create a basic Poetry, Hatch or PDM setup:</p> <pre><code>git init\n</code></pre>"},{"location":"setup/#poetry","title":"Poetry","text":"<pre><code>poetry init\n</code></pre> <p>From the Poetry docs:</p> <p>This command will help you create a pyproject.toml file interactively by prompting you to provide basic information about your package. It will interactively ask you to fill in the fields, while using some smart defaults.</p> <p>Create a workspace, with a basic Polylith folder structure.</p> <pre><code>poetry poly create workspace --name my_namespace --theme loose\n</code></pre> <p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace, <code>loose</code> is the recommended structure for Python.</p> <p>Create a virtual environment for the workspace.</p> <pre><code>poetry install\n</code></pre>"},{"location":"setup/#hatch","title":"Hatch","text":"<pre><code>hatch new --init\n</code></pre> <p>From the Hatch docs:</p> <p>Create or initialize a project. </p> <p>Note: using <code>--init</code> to avoid creating any boilerplate code.</p> <p>Add the Polylith CLI as a dev dependency, and configuration for the virtual environment in the <code>pyproject.toml</code> file:</p> <pre><code>[tool.hatch.envs.default]\ndependencies = [\"polylith-cli\"]\ntype = \"virtual\"\npath = \".venv\"\npython = \"3.12\"  # your preferred version here\n\n[tool.hatch.build]\ndev-mode-dirs = [\"components\", \"bases\", \"development\", \".\"]\n</code></pre> <p>Create a Hatch virtual environment: <pre><code>hatch env create\n</code></pre></p> <p>Create a workspace, with a basic Polylith folder structure.</p> <pre><code>hatch run poly create workspace --name my_namespace --theme loose\n</code></pre> <p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace, <code>loose</code> is the recommended structure for Python.</p>"},{"location":"setup/#pdm","title":"PDM","text":"<pre><code>pdm init -n --backend pdm-backend minimal\n</code></pre> <p>From the PDM docs</p> <p>Initialize with the builtin \"minimal\" template, that only generates a pyproject.toml.</p> <p>and PDM init</p> <p>Specify the build backend, which implies --dist</p>"},{"location":"setup/#add-a-workspace-hook","title":"Add a workspace hook","text":"<p>Make <code>PDM</code> aware of the Polylith structure, by adding the <code>pdm-polylith-workspace</code> hook to the newly created <code>pyproject.toml</code>.</p> <p>The build hook will add an additional <code>pth</code> file to the virtual environment, with paths to the Polylith source code folders (bases, components).</p> <pre><code>[build-system]\nrequires = [\"pdm-backend\", \"pdm-polylith-workspace\"]\nbuild-backend = \"pdm.backend\"\n</code></pre>"},{"location":"setup/#add-the-polylith-cli","title":"Add the polylith-cli","text":"<p>Add the Polylith CLI as a dev dependency and setup the virtual environment paths.</p> <pre><code>touch README.md\n\npdm add -d polylith-cli\n\npdm install\n</code></pre> <p>Next: create a Polylith workspace, with a basic Polylith folder structure. The <code>poly</code> command is now available in the local virtual environment. You can run commands in the context of <code>pdm run</code> to make Polylith aware of the development environment.</p> <pre><code>pdm run poly create workspace --name my_namespace --theme loose\n</code></pre> <p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace, <code>loose</code> is the recommended structure for Python.</p>"},{"location":"setup/#rye","title":"Rye","text":"<pre><code>rye init my_repo  # name your repo\n\ncd my_repo\n\nrye add polylith-cli --dev\n\nrye sync  # create a virtual environment and lock files\n</code></pre> <p>Create a workspace, with a basic Polylith folder structure.</p> <pre><code>rye run poly create workspace --name my_namespace --theme loose\n</code></pre> <p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace, <code>loose</code> is the recommended structure for Python.</p>"},{"location":"setup/#edit-the-configuration","title":"Edit the configuration","text":"<p>The default build backend for Rye is Hatch. Make Rye (and Hatch) aware of the way Polylith organizes source code: <pre><code>[tool.hatch.build]\ndev-mode-dirs = [\"components\", \"bases\", \"development\", \".\"]\n</code></pre></p> <p>Remove the <code>[tool.hatch.build.targets.wheel]</code> section.</p> <p>Run the <code>sync</code> command to update the virtual environment:</p> <pre><code>rye sync\n</code></pre> <p>Finally, remove the <code>src</code> boilerplate code that was added by Rye in the first step: <pre><code>rm -r src\n</code></pre></p>"},{"location":"setup/#uv","title":"uv","text":"<pre><code>uv init my_repo  # name your repo\n\ncd my_repo\n\nuv add polylith-cli --dev\n\nuv sync  # create a virtual environment and lock files\n</code></pre> <p>Create a workspace, with a basic Polylith folder structure.</p> <pre><code>uv run poly create workspace --name my_namespace --theme loose\n</code></pre> <p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace, <code>loose</code> is the recommended structure for Python.</p>"},{"location":"setup/#edit-the-configuration_1","title":"Edit the configuration","text":"<p>The default build backend for uv is Hatch. Make uv (and Hatch) aware of the way Polylith organizes source code: <pre><code>[tool.hatch.build]\ndev-mode-dirs = [\"components\", \"bases\", \"development\", \".\"]\n</code></pre></p> <p>Run the <code>sync</code> command to update the virtual environment:</p> <pre><code>uv sync\n</code></pre> <p>Finally, remove the <code>src</code> boilerplate code that was added by uv in the first step: <pre><code>rm -r src\n</code></pre></p>"},{"location":"setup/#pantsbuild-aka-pants","title":"Pantsbuild (aka Pants)","text":"<p>Have a look in the Pants-specific example repository for details on the setup. You will find examples of combining Pants with Polylith, by using the Hatch build backend in the project-specific configurations.</p> <p>You will find more documentation about the available commands in the commands section.</p>"},{"location":"testing/","title":"Testing","text":"<p>The code that you write in the bricks is just Python. That means you can use your favorite tools as you would with any mainstream Python project.</p>"},{"location":"testing/#testing-bricks","title":"Testing Bricks","text":"<p>By default, tests are added when creating a new component or base with the <code>poly create</code> command. This is optional and can be turned off in the Workspace configuration. The tests are added in a <code>test</code> folder at the root of the workspace with the same kind of folder structure as the bricks.</p>"},{"location":"testing/#example","title":"Example","text":"<p>Creating a new <code>parser</code> component. This will add a new brick to the <code>components</code> folder.</p>"},{"location":"testing/#poetry","title":"Poetry","text":"<pre><code>poetry poly create component --name parser\n</code></pre>"},{"location":"testing/#hatch","title":"Hatch","text":"<pre><code>hatch run poly create component --name parser\n</code></pre>"},{"location":"testing/#pdm","title":"PDM","text":"<pre><code>pdm run poly create component --name parser\n</code></pre>"},{"location":"testing/#rye","title":"Rye","text":"<pre><code>rye run poly create component --name parser\n</code></pre>"},{"location":"testing/#uv","title":"uv","text":"<pre><code>uv run poly create component --name parser\n</code></pre> <p>A corresponding unit test will also be created in the <code>test</code> folder: <pre><code>from my_top_namespace.parser import core\n\n\ndef test_sample():\n    assert core is not None\n</code></pre></p> <p>Add the proper assertions to your tests during development of the bricks.</p>"},{"location":"testing/#running-tests","title":"Running tests","text":"<p>Running Pytest from the workspace root:</p>"},{"location":"testing/#poetry_1","title":"Poetry","text":"<pre><code>poetry run pytest\n</code></pre>"},{"location":"testing/#hatch_1","title":"Hatch","text":"<pre><code>hatch run pytest\n</code></pre>"},{"location":"testing/#pdm_1","title":"PDM","text":"<pre><code>pdm run pytest\n</code></pre>"},{"location":"testing/#rye_1","title":"Rye","text":"<pre><code>rye run pytest\n</code></pre>"},{"location":"testing/#uv_1","title":"uv","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"testing/#running-tests-with-pytest-and-the-tdd-theme","title":"Running tests with pytest and the TDD Theme","text":"<p>This configuration ensures the entire namespace of your brick is included when <code>pytest</code> does it's test lookup. Without it, <code>pytest</code> will raise errors because of the default way it does module lookups. This occurs when using Polylith with the TDD theme.</p> <pre><code>[tool.pytest.ini_options]\naddopts = [\n    \"--import-mode=importlib\",\n]\n</code></pre>"},{"location":"testing/#running-tests-for-changed-code","title":"Running tests for changed code","text":"<p>The Python tools for the Polylith Architecture doesn't (yet) have a specific <code>test</code> command. You can use <code>poly diff</code> and your favorite test runner to only run the corresponding tests for changed code.</p> <p>The <code>diff</code> command has support for displaying the changed bricks by using <code>--bricks</code>. Append the <code>--short</code> option for a scripting-friendly output.</p> <p>You can use the output from the <code>poly diff</code> command to run specific tests. Storing a list of bricks in a bash variable:</p>"},{"location":"testing/#poetry_2","title":"Poetry","text":"<pre><code>changes=\"$(poetry poly diff --bricks --short)\"\n</code></pre>"},{"location":"testing/#hatch_2","title":"Hatch","text":"<pre><code>changes=\"$(hatch run poly diff --bricks --short)\"\n</code></pre>"},{"location":"testing/#pdm_2","title":"PDM","text":"<pre><code>changes=\"$(pdm run poly diff --bricks --short)\"\n</code></pre>"},{"location":"testing/#rye_2","title":"Rye","text":"<pre><code>changes=\"$(rye run poly diff --bricks --short)\"\n</code></pre>"},{"location":"testing/#uv_2","title":"uv","text":"<pre><code>changes=\"$(uv run poly diff --bricks --short)\"\n</code></pre> <p>To include bricks that use any of the changed bricks, you can add the <code>--deps</code> option. This will append any dependent bricks to the output.</p> <p>By having tests in the same kind of structure as the bricks, you can use the output from the <code>poly diff</code> command to pick the tests to run. You can also name the individual test functions to include brick names, or use decorators (such as <code>pytest</code> markers).</p>"},{"location":"testing/#pytest","title":"Pytest","text":"<p>Transform the result of the <code>poly diff</code> command into a Pytest keyword or marker expression. (i.e. from hello,world,something to hello or world or something).</p> <ul> <li><code>-k</code> is for running tests by keyword expressions.</li> <li><code>-m</code> is for running tests by marker expressions.</li> </ul>"},{"location":"testing/#poetry_3","title":"Poetry","text":"<pre><code>query=\"${changes//,/ or }\"\n\npoetry run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"testing/#hatch_3","title":"Hatch","text":"<pre><code>query=\"${changes//,/ or }\"\n\nhatch run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"testing/#pdm_3","title":"PDM","text":"<pre><code>query=\"${changes//,/ or }\"\n\npdm run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"testing/#rye_3","title":"Rye","text":"<pre><code>query=\"${changes//,/ or }\"\n\nrye run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"testing/#uv_3","title":"uv","text":"<pre><code>query=\"${changes//,/ or }\"\n\nuv run pytest -k &lt;&lt;&lt; echo \"$query\"\n</code></pre>"},{"location":"testing/#manually-testing-and-running-services","title":"Manually testing and running services","text":"<p>The <code>bases</code> and <code>components</code> is plain Python, and the code can be run as you would if it were a single project repository. The bases are the entry points to your services and apps.</p>"},{"location":"testing/#example-running-a-fastapi-service-locally","title":"Example: running a FastAPI service locally","text":"<p>Start the service by specifying the namespace path to your entry point (i.e. the <code>base</code>). <pre><code>uvicorn my_top_namespace.my_fastapi_service.core:app\n</code></pre></p> <p>It is also possible to test out project-specific entries that are defined in a <code>pyproject.toml</code> as you would in a mainstream Poetry project.</p>"},{"location":"videos/","title":"Videos &amp; tutorials","text":""},{"location":"videos/#videos","title":"Videos","text":"<ul> <li>Python with the Polylith Architecture - an overview (about 15 minutes)</li> <li>Python Poetry Polylith Plugin - the tooling support &amp; commands (about 13 minutes)</li> <li>The Developer Experience<ul> <li>developing a Dad Joke Service with Polylith (about 27 minutes)</li> <li>the Polylith Dev Experience using Hatch and Rye (about 7 minutes)</li> </ul> </li> <li>The standalone Polylith CLI - An intro to the polylith-cli - tooling support for Polylith with Python and Hatch</li> </ul>"},{"location":"videos/#talks","title":"Talks","text":"<ul> <li>PyCon Sweden 2023: Python Developer Experience with Polylith (about 25 minutes + Q&amp;A)</li> <li>Python Web Conference 2023: A Fresh Take on Monorepos in Python (about 36 minutes) Microservices, Monolith, Monorepos: the differences &amp; how nicely Polylith solves the trade offs.</li> </ul>"},{"location":"videos/#podcasts","title":"Podcasts","text":"<ul> <li>Talk Python To Me: Monorepos in Python</li> </ul>"},{"location":"videos/#articles","title":"Articles","text":"<ul> <li>The last Python Architecture you will ever need?</li> <li>A Fresh Take on Monorepos in Python</li> <li>A simple &amp; scalable Python project structure</li> <li>Aws CDK App with polylith code architecture by Yoel Ben\u00edtez Fonseca</li> <li>GCP Cloud Functions with Python and Polylith</li> <li>Python FastAPI Microservices with Polylith</li> <li>Kafka messaging with Python &amp; Polylith</li> <li>Runestone Monorepo and Server Structure by Minh-Thao Pham</li> <li>Python Monorepo Visualization</li> </ul> <p>Got an article or video about this subject that you want to share here? You are very much welcome to make a Pull Request, or a Github issue to the python-polylith-docs repo.</p>"},{"location":"workspace/","title":"The Polylith Workspace","text":"<p>The  workspace is the root directory of a repository. The basic structure of a Polylith Workspace would look something like this:</p> <pre><code>workspace/\n  bases/\n  components/\n  development/\n  projects/\n\n  pyproject.toml\n  workspace.toml\n\n  README.md\n</code></pre> <p>The building blocks are found in the bases and components folders. That's where the Python code is put.</p>"},{"location":"workspace/#bases","title":"bases","text":"<p>Bases are the building blocks that exposes a public API to the outside world. <sup>1</sup></p> <p>A base is a special kind of Polylith brick. It is where you would add the entry point of an app or a REST API. It is a bridge between the outside world and the actual features.</p>"},{"location":"workspace/#components","title":"components","text":"<p>A component is an encapsulated block of code that can be assembled together with a base (it's often just a single base) and a set of components and libraries into services, libraries or tools. Components achieve encapsulation and composability by separating their private implementation from their public interface. <sup>1</sup></p> <p>A component is also a brick, a building block for a feature.  It can be a \"tech\" brick, such as containing dictionary filtering helper functions, or a parser. It can also be a wrapper for a third-party library. A brick is also very likely a combination of other bricks. The combination of bricks becomes a feature. Very much like LEGO.</p>"},{"location":"workspace/#development","title":"development","text":"<p>The development folder is where you can put code that you write to experiment or try out features. It is similar to the scratch files in JetBrains PyCharm!</p> <p>The development folder is part of the development project, that is defined in the <code>pyproject.toml</code> and the <code>poetry.lock</code> file of the root folder. Here, you add all dependencies and bricks. This will make it possible to have the entire code-base available in one and the same virtual environment.</p> <p>In this folder, it is quite common that developers keep their scratch-style Python modules. It is perfectly fine to version control them. It is a place for REPL Driven Development and Jupyter Notebooks!</p> <pre><code>development/\n   sofia.py\n   david.py\n   data.ipynb\n</code></pre>"},{"location":"workspace/#projects","title":"projects","text":"<p>A project is the result of combining one base (or in rare cases several bases) with multiple components and libraries. <sup>1</sup></p> <p>Each project lives in a subdirectory of the <code>projects/</code> folder. A project is the deployable artifact: a microservice, a serverless function, a CLI or any kind of application.</p> <pre><code>projects/\n   my_aws_lambda/\n   my_fast_api_service/\n</code></pre> <p>In the project-specific directory, you will find a project-specific <code>pyproject.toml</code> that defines dependencies, packages and everything needed for the actual project. It is not recommended to put Python code in here. Just add the necessary project infrastructure, such as Dockerfiles and project-specific deploy scripting.</p> <ol> <li> <p>From the official Polylith Architecture documentation \u21a9\u21a9\u21a9</p> </li> </ol>"}]}